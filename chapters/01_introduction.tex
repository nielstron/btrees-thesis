% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}

The goal of this thesis is to obtain an implementation of B-Trees in the Isabelle/HOL Framework.
The approach is to first design a functional, abstract implementation.
This implementation is the shown to implement a Set-interface,
correctly implementing retrieval, insertion and deletion operations.
In a last step, an imperative implementation is derived that
refines the functional variant.
Thus the proof of correctness for the imperative implementation
is reduced to a proof of equivalence between the output of the
functional and the imperative implementation.
Desirable properties regarding low runtime and high storage usage
are preserved by the obtained implementation.

\section{The Isabelle Proof Assistant}

The Isabelle/HOL tool is an interactive theorem prover.
The user outlines a proof and tells the system which proof methods to apply to
resolve each step.
% TODO more info

Isabelle/HOL is built on PolyML, a functional language similar to OCaml
and Haskell.
The implementation will hence make use of newly defined functions, where
\texttt{definition} denotes classical definitions and \texttt{fun} (an abbreviation of "function")
is used for recursive definition.

% function notation (like haskell/OCaml)
% NOTE all functions terminate, unless declared "partial"
% can write mathematical expressions (?)
% list notation etc
% proof styles, methods (?)
% locales
% set specification
% TODO cite isabelle resources

\section{The B-Tree Data Structure}

B-Trees were first proposed by Bayer et al. in \parencite{DBLP:journals/acta/BayerM72},
as a data-structure to efficiently store and retrieve indices stored on storage devices
with slow memory access.
In general, B-Trees are hence a special kind of balanced search-trees.
They are different from binary trees in that the number of subtrees is not constant 2
but is defined by the \textit{order} \texttt{k} of the tree.

\subsection{Definitions}
\label{sec:data_structure_defs}

Every node contains a list of \texttt{keys} or \texttt{separators}, index elements, and \texttt{subtrees},
that refer to further B-Trees.
The length of this list is bounded by \texttt{k}.
The separators and subtrees are considered interleaved within a node,
such that we can speak of a subtree left of a separator and a subtree right of a separator,
where for a separator at index \texttt{i} we mean the subtree in the respective
subtree list at index \texttt{i} and \texttt{i+1} respectively.
Note that this already implies that the list of subtrees is one
longer than the list of separators - we refer to the last subtree as the \textit{last} or
\textit{dangling} subtree.
In \parencite{DBLP:journals/acta/BayerM72},
a B-Tree with above structure must fulfill the three properties
\textit{balancedness}, \textit{order} and \textit{sortedness}.

\textit{Balancedness} requires that each path from the root to any leaf has the same length \texttt{h},
in other words that the height of all trees in one level of the tree must be equal.

Further the indices must be \textit{sorted} within the tree which means that all indices stored
in the subtree left of a separator are smaller than the value of the separator
and all indices on the right are greater.

In general terms, the property of \textit{order} ensures a certain minimum and maximum
number of subtrees for each node.
However, as pointed out in \parencite{DBLP:books/daglib/0095349_mod},
the property is defined differently in the literature.
For the purpose of this work, the original definition by Bayer et al. was chosen as most suitable.
A B-Tree is of order \textit{k}, if each internal node has at least \textit{k+1}
subtrees and at most \textit{2*k+1}.
The alternative of defining the nodes to have between $\lceil \frac{k}{2} \rceil$
and $k$ children (as proposed in \parencite{DBLP:books/lib/Knuth98a}),
involves cumbersome \textit{real} arithmetic that unnecessarily complicates
mechanized proofs.
Sticking to this definition is further supported by the fact that nodes are supposed
to fill memory pages which are usually of even size (usually some power of 2).
An even number of separators and trees plus one dangling last right tree maximizes
the usage of such a page.

The same ambiguity exists for the term \textit{Leaf} which we will define consistently with Knuth's definition \parencite{DBLP:books/lib/Knuth98a}
to be an empty node, carrying no information.
This is closest to the usual approach in functional programming.
The lowest level of nodes hence contains a list of separators and
list of pointers to leaves.

% TODO insert image of valid B-Tree

\subsection{Desirable Properties}

Due to the potentially large branching factor, combined with the balancing,
the amount of required memory accesses when accessing data is reduced drastically.
This is due to the fact that the overall number of memory accesses is bounded by the depth
of the tree, which again is logarithmic in the number of indices -
where the base of the logarithm is closely proportional to the order \textit{k} of the tree.

Further, the storage usage of B-Trees is at a minimum of $50\%$ at all times,
where the average usage is usually higher. \parencite{DBLP:journals/acta/BayerM72}
This is due to the fact that every node reserves the storage of $2*k$ keys and separators
and by definition always contains at least $k$ elements.

These properties are key to the widespread popularity of B-Trees and are
hence preserved in the given implementation.


\subsection{Applications}

B-Trees are used in almost all modern databases for storing key-value pairs.

\chapter{Functional B-Trees in Isabelle}

Functional specifications of data structures tend to have properties that
are easier to prove than for corresponding imperative implementations
mostly due to the fact that many details of implementation can be abstracted away.
The work therefore begins with a functional specification of B-Trees.

\section{Basic Definitions}
\label{sec:basic-defs}
%Definition used for this implementation.
%(esp. order)
%note that k refers to keys+subtrees rather than only keys/subtrees (false! we have k pairs)

% TODO all function equations similar to math equations, setting variables in italics

Inspired by the design in \parencite{DBLP:conf/popl/MalechaMSW10}, the B-Tree data-structure is defined as follows:

\begin{lstlisting}[mathescape=true, language=Isabelle,label=lst:btree-def]
datatype 'a btree = Leaf | Node ( 'a btree * 'a ) list 'a btree
\end{lstlisting}

By interleaving the subtrees and separators, expression of invariants
on the tree is possible without the explicit use of indices into lists.
Since the list of trees is exactly one longer than the list of keys,
the last tree is added to the node in a special position.
The construction leads to the fact that it is easiest to relate any separator
to the subtree on the left, as this subtree is in the same tuple.
Operations that require the subtree on the right can always be expressed as a special
operation on the last tree.

The balancedness of a B-Tree is defined in a straightforward fashion, making use
of an intuitively defined height.\footnote{
    Note that the actual implementation of height is slightly different,
    however this is of no importance in any proofs but rather notationally convenient.
}
There is a choice here, namely whether to fix the balancedness of a tree
on some arbitrary number or on a known value.
Since we know the last tree in the node exists and further
know that all in the node have the same height as that tree,
we simply choose the height of the last tree as an anchor point.

\begin{lstlisting}[mathescape=true, language=Isabelle]

fun height :: 'a btree $\Rightarrow$ nat where
  height Leaf = 0 |
  height (Node ts t) = Suc (fold max (map height (subtrees ts)) (height t))

fun bal :: 'a btree $\Rightarrow$ bool where
    bal Leaf = True |
    bal (Node ts t) = (
      ($\forall$sub $\in$ set (subtrees ts). height t = height sub) $\wedge$
      ($\forall$sub $\in$ set (subtrees ts). bal sub) $\wedge$
      bal t
    )
\end{lstlisting}

Further the \textit{order} of the trees needs to be formally defined.
As discussed in \autoref{sec:data_structure_defs}, the most useful choice here is
to allow for at least $k$ and at most $2*k+1$ subtrees.
Since the last subtree is fixed, this means that the length of list of keys and children
itself has to be between $k$ and $2*k$.
Note that we also need a special property for the root of the tree,
which has between one and $2*k$ elements.
In mathematical equations, we will denote "order $k$ $t$" as "$\order_k t$"
for convenience (likewise for "root\_order $k$ $t$"), which is to be read as
"Tree $t$ is of order $k$".

\begin{lstlisting}[mathescape=true, language=Isabelle]

fun order :: nat $\Rightarrow$ 'a btree $\Rightarrow$ bool where
    order k Leaf = True |
    order k (Node ts t) = (
    (length ts $\ge$ k)  $\wedge$
    (length ts $\le$ 2*k) $\wedge$
    ($\forall$sub $\in$ set (subtrees ts). order k sub) $\wedge$
    order k t
  )

fun root_order where
  root_order k Leaf = True |
  root_order k (Node ts t) = (
  (length ts $>$ 0) $\wedge$
  (length ts $\le$ 2*k) $\wedge$
  ($\forall$s $\in$ set (subtrees ts). order k s) $\wedge$
   order k t
)

\end{lstlisting}

We define the sortedness of a B-Tree based on the \textit{inorder} of the tree,
which is the concatenation of all elements of the tree in in-order traversal.
A concatenation function for lists of strings
is employed to express the resulting string,
since each node does no longer have a constant maximum number of elements (as opposed to
e.g. 2-3-4-Trees in \parencite{DBLP:conf/itp/Nipkow16}),
Note that this definition reads a bit inconveniently
as the node internal list is first mapped and then concatenated.
However since we make recursive use of the inorder-function
inside the mapping expression, we can only later on cover up this expression
by using abbreviations.
In mathematical terms in the following, we will not distinguish between lists, 
pairs or trees when talking about their inorder representation.

\begin{lstlisting}[mathescape=true, language=Isabelle]
fun inorder :: 'a btree $\Rightarrow$ 'a list where
    inorder Leaf = [] |
    inorder (Node ts t) = 
        concat (map ($\lambda$ (sub, sep). inorder sub @ [sep]) ts)
        @ inorder t

abbreviation inorder_pair  $\equiv$ $\lambda$(sub,sep). inorder sub @ [sep]
abbreviation inorder_list ts $\equiv$ concat (map inorder_pair ts)
\end{lstlisting}

That way we can express sortedness of the tree $t$ as a simple $\sorted (\inorder t)$,
where sorted returns whether each element is strictly smaller ($<$) than the elements in the remaining list.
This definition is very compact and brings for another benefit pointed out by Nipkow et al in \parencite{DBLP:conf/itp/Nipkow16}.
Many properties of B-Trees follow intuitively by considering
the inorder view on the tree as it is invariant for many operations (i.e. stealing from the right neighbor node).
We will see later how the use of this fact comes in handy for proving
important properties of the implementation.
 % TODO note benefit over btree_sorted

\section{Height of B-Trees}

%Height etc.
As pointed out by Bayer in the first paper describing B-Trees,
the height of B-Trees is logarithmic with respect to the number
of nodes of the tree. \parencite{DBLP:journals/acta/BayerM72}
The paper even gives a precise lower and upper bound, which will be quickly sketched in the following.

First, we define the number of nodes in a tree:
\begin{lstlisting}[mathescape=true, language=Isabelle]
fun nodes :: 'a btree $\Rightarrow$ nat where
    nodes Leaf = 0 |
    nodes (Node ts t) =
        1 + $\sum$t$\leftarrow$subtrees ts. nodes t + nodes t
\end{lstlisting}

%To work with this equation, we just need to add one auxiliary lemmas to the standard canon
%\begin{lemma}
%\begin{lstlisting}[mathescape=true, language=Isabelle]
%    sum_list (replicate n c) = n*c
%\end{lstlisting}
%\end{lemma}

We obtain bounds
on the number of nodes of an subtree with respect to its height
by induction on the computation of the nodes function.

\begin{lemma}
    \label{lem:bound_internal_node}
    $\order_k t \wedge \bal t \longrightarrow$
    \begin{align}
        (k+1)^{\height t} - 1 &\le \nodes t * k \\
        \nodes t * 2k &\le (2k+1)^{\height t} - 1
    \end{align}
\end{lemma}

From \autoref{lem:bound_internal_node} we can almost directly obtain
the bounds on valid roots of B-Trees.
The only difference to the bound of internal nodes occurs on the lower bound side.
The issue here is that a root node may contain less elements than
a valid internal node (namely only one), which yields two subtrees with known height
plus one for the node itself.
Note that these are the exact bounds obtained by Bayer et al. in \parencite{DBLP:journals/acta/BayerM72},
except for the fact that we have generalized the equation,
incorporating whether $t$ is a tree or not.\footnote{
    If $t$ is in fact a Leaf,
    $2((k+1)^{\height t - 1} - 1) \div k + (t \neq Leaf)$ becomes a fancy way of writing $0$.
}

\begin{theorem}
    $\rootorder_k t \wedge \bal t \wedge k > 0 \longrightarrow$
    \begin{equation}
        2((k+1)^{\height t - 1} - 1) \div k + (t \neq Leaf) \le \nodes t \le ((2k+1)^{\height t} - 1) \div 2k
    \end{equation}
\end{theorem}

These results are very interesting, because
the runtime of all further operations will more or less trivially be
directly proportional to the height of the tree.
Therefore, we are glad to see that the height is logarithmic
with respect to the number of nodes stored in the tree.

These bounds are sharp, which we prove by providing 
functions that generate exactly those trees
that satisfy the requirements of B-Trees, have a given height
and satisfy the inequality with equality.
The proof for internal nodes follows by induction over the creation,
the rule for the roots follows directly.

\begin{lstlisting}[mathescape=true, language=Isabelle]

fun full_node where
  full_node k c 0 = Leaf |
  full_node k c (Suc n) = (
      Node
        (replicate (2*k) ((full_node k c n),c))
        (full_node k c n)
  )

fun slim_node where
  slim_node k c 0 = Leaf |
  slim_node k c (Suc n) = (
      Node
        (replicate k ((slim_node k c n),c))
        (slim_node k c n)
    )

definition full_tree = full_node

fun slim_tree where
  slim_tree k c 0 = Leaf |
  slim_tree k c (Suc h) =
    Node
        [(slim_node k c h, c)]
        (slim_node k c h)

\end{lstlisting}

%TODO (?) images of slim/full trees

\begin{lemma} $t_f := \fullnode k\ a\ h \wedge t_s := \slimnode k\ a\ h \longrightarrow$
    \begin{align}
    h = \height t_s = \height t_f \wedge \\
    ((2k+1)^h - 1) &= \nodes t_f * (2k) &\wedge \order_k t_f \wedge \bal t_f \\ 
    ((k+1)^h - 1) &= \nodes t_s * k  &\wedge \order_k t_s \wedge \bal t_s
    \end{align}
\end{lemma}

% TODO prove div version of thm
\begin{theorem}
    $k > 0 \wedge t_f := \fulltree k\ a\ h \wedge t_s := \slimtree k\ a\ h \longrightarrow$
    \begin{align}
    h = \height t_s = \height t_f \wedge \\
        ((2k+1)^h - 1) \div 2k &= \nodes t_f &\wedge \rootorder_k t_f \wedge \bal t_f \\ 
        2((k+1)^h - 1) \div k + (t_s \neq Leaf) &= \nodes t_s &\wedge \rootorder_k t_s \wedge \bal t_s
    \end{align}
\end{theorem}


\section{Set operations}

With the definition of B-Trees come a number of operations that allow for set-like operations
on the trees - retrieval, insertion and deletion.
In the Isabelle/HOL framework, there is a standard interface
for data structures that provide an implementation of sets.

\subsection{The Set Interface}
% Description of the set interface

An implementation $'a t$ of the sets of elements of type $'a$ is required to provide the following
operations

\begin{itemize}
    \itshape
    \item empty :: 'a t
    \item isin :: 'a t $\Rightarrow$ 'a $\Rightarrow$ bool
    \item insert :: 'a $\Rightarrow$ 'a t $\Rightarrow$ 'a t
    \item delete :: 'a $\Rightarrow$ 'a t $\Rightarrow$ 'a t
\end{itemize}

For this work, using the definition from \autoref{lst:btree-def},
we consider \textit{'a t = 'a btree} in all above equations.
The standard approach is to show that we can provide functions for the B-Tree
that have the same effect as insertion, deletion or testing on contained elements
in abstract sets with the same elements.

However, using an inorder function to
as an intermediate abstraction step, proofs tend to become simpler for a simplifying
based prover to resolve. 
This method has been applied in \parencite{DBLP:conf/itp/Nipkow16} and yielded
fully automatic proofs.
We therefore resort to the alternative interface proposed in that work.
In addition to an \textit{invariant}
it requires a function \textit{inorder :: 'a t $\Rightarrow$ 'a list}
that is associated with the inorder traversal of the tree.
The invariant and inorder functions follow directly from the
definition of B-Trees in \autoref{sec:basic-defs}.
What is needed in addition are the set operations
and the proof that they maintain the invariants.


\subsection{The split-Function}
% Description of the implementation of the set interface.
% TODO note that the proof for  sortedness has been reduced from 2000 lines
% by the sorted (inorder ...) notation (and Nipkows auxiliary funs/lemmas)

Naturally the set operations are defined recursively on the nodes of the tree.
Since each node contains a non-trivial number of elements,
a function to navigate to the correct separator and subtree is central to all operations.

We call this function \textit{split}-function,
determining the position in the list of separators and subtrees at which
either the separator is equal to the desired value or the range of the left subtree
contains the desired value.
Since the whole tree is sorted, we know that if the element being searched for
is contained anywhere in the tree, it must be in that subtree.
This approach is similar to the one found in the work of Malecha and Fielding \parencite{DBLP:conf/popl/MalechaMSW10,Fielding80}.\footnote{
    In Fieldings approach the corresponding function is called \textit{index}.
    Malecha calls it \textit{findSubtree}.
}
Usually however, it is integrated into the set-operation
by a linear search that is promised to be replaced by a more efficient binary search
in the actual implementation \parencite{DBLP:books/daglib/0023376,DBLP:journals/acta/BayerM72}
or left in the final code \parencite{DBLP:journals/sosym/ErnstSR15}

The precise inner workings of the split function are not of interest here
and actually are not supposed to be interesting on the functional level.
Of course \textit{some} kind of function is required that correctly splits
the key-value list and an example is given in \autoref{fig:linear_split}.
In the process of implementing the set specifications,
this concrete function was used to explore the provability of the set methods.
However it quickly turned out that 1) only specific lemmas about the split
function are useful during proofs and 2) only relying on an abstract specification of
the split method would simplify integrating alternative splitting functions.
Most notably, the abstraction allows to later plug-in a very efficient splitting
function, e.g. based on binary search.

\begin{figure}
    
\begin{lstlisting}[mathescape=true, language=Isabelle]
fun linear_split_help where
  linear_split_help [] x prev = (prev, []) |
  linear_split_help ((sub, sep)#xs) x prev = (
      if sep < x then
        linear_split_help xs x (prev @ [(sub, sep)])
      else
        (prev, (sub,sep)#xs)
  )

fun linear_split:: ('a btree$\times$'a) list $\Rightarrow$ 'a $\Rightarrow$ (_ list $\times$ _ list) where
  linear_split xs x = linear_split_help xs x []
\end{lstlisting}
\caption{A function implementing the split function specifications.
It scans linearly through the list, returning the first tuple where the separator
or subtree could potentially contain the value $x$}
\label{fig:linear_split}

\end{figure}

Therefore all set functions are defined based the following requirements:

\begin{itemize}
    \item $\splitfun xs\ p = (ls,rs) \Longrightarrow xs = ls @ rs$
    \item $\splitfun xs\ p = (ls@[(sub,sep)],rs) \wedge \sorted (\separators xs) \Longrightarrow sep < p$
    \item $\splitfun xs\ p = (ls,(sub,sep)\#rs) \wedge \sorted (\separators xs) \Longrightarrow p \le sep$
\end{itemize}

Described in natural language, the split function should return two sublists
that concatenate to the original list.
Further if the elements came in sorted order,
the list is split such that the key to the left is strictly less than the desired value
and the key to the right less or equal.

The benefit of restricting the sortedness of the list only to its separators
simplifies the proofs of showing that a certain function fulfils the split abstraction.
We really only need to consider the separators on each level and not the subtrees themselves.
Showing that the function works on a sorted inorder list
would only introduce an additional step to follow that the separators are sorted as well.
Having fixated this abstraction we only need to follow this fact once
and can relieve the writer of split functions of the need to do so.

The abstraction was formulated in a locale.
Inside the locale we have access to exactly the specified split function,
without knowing anything about the composition of that function.

\subsection{Implementation of the Set interface}

The simplest operation required in the Set interface is
the \textit{isin} function.
Its definition below also shows exemplary usage of the split function.
In case the right part of the split list is non-empty,
we check the element at that level or recurse in the given subtree.
Otherwise, we may directly recurse to the last tree in the node.

\begin{lstlisting}[mathescape=true, language=Isabelle]
fun isin:: 'a btree $\Rightarrow$ 'a $\Rightarrow$ bool where
    isin (Leaf) y = False |
    isin (Node ts t) y = (
        case split ts y of (_,rs) $\Rightarrow$ (
            case rs of (sub,sep)#_ $\Rightarrow$ (
                if y = sep then
                    True
                else
                    isin sub y
            )
        | [] $\Rightarrow$ isin t y
        )
    )
\end{lstlisting}

By the standard set interface the operation is only required to work on
sorted, balanced trees of a certain order, however only the former is actually required
for correctness.
The following lemma shows the required property of the function

\begin{theorem}
    \label{thm:isin-set}
    $\sorted (\inorder t) \Longrightarrow \isinfun t\ x = (x \in \setfun (\inorder t))$
\end{theorem}

It follows by induction on the evaluation of the isin function.
To prove it, we also invoke two specialized lemmas,
that simplify arguments about the choice of the node for recursion.
The kind of lemmas are of special interest as they specialize
an idea proposed in \parencite{DBLP:conf/itp/Nipkow16} and
are used for the correctness proofs of insert and delete alike.

\begin{lemma}
    $\sorted (\inorder t) \wedge \splitfun ts\ x = (ls, rs) \Longrightarrow$ \\
    $x \in (\setfun (\inorder (Node\ ts\ t))) = (x \in \setfun (\inorder rs @ \inorder t))$
\end{lemma}

The idea of this fact is to argue that, if the split function has provided
us with a given splitting, it is safe to limit the further search
to the right side of the split.
It follows directly from the requirements on the split function.
If $rs$ is empty, we can follow that the element has to reside in the inorder
of the last tree of the node.
When used in the inductive proof of \autoref{thm:isin-set}, we can then deduce that this is
equal to $\isinfun t\ x$, the branch taken in the isin function for an empty right split result.
If $rs$ is not empty, we need an additional lemma.

\begin{lemma}
    $\sorted (\inorder t) \wedge \splitfun ts\ x = (ls, (sub,sep)\#rs) \wedge sep \neq x \Longrightarrow$ \\
    $x \in (\setfun (\inorder (sub,sep)\#rs @ \inorder t)) = (x \in \setfun (\inorder sub))$
\end{lemma}

With this lemma we know that the first subtree on the right part of the split
is the correct child to recurse into.
The requirement of $sep \neq x$ comes from the fact that in case $sep = x$,
no recursion is required at all.
The desired element was just found.

This operation has no effect on the tree, it only walks through it.
This fact follows directly due to the persistence of functional data structures.
Hence, no proof of preserved invariant is required.

However this is not true for the \textit{insertion} function.
There is much consensus in the literature on how to conduct insertion into a B-Tree
%TODO citations
Generally, an element is inserted into leaf nodes.
In case that there is enough space, the node is simply placed at the correct
position in the list of separators.
However if the node has more than $2k$ elements after this insertion,
we need to split it and, passing the median to the parent node,
recurse back upwards.

prove everything based on abstract definition -> locale % TODO add to isabelle intro


\chapter{Imperative B-Trees in Isabelle}

\section{The Imperative Refinement Framework}

Short Description of Peters Refinement framework regarding our implementation

\section{Important low-level data structures}

Note the existence of arrays and blit.
Note further the introduction of partially filled arrays
and the introduction of sblit.

\section{Set-Operations}

\subsection{The split function}

Note the choice of a while-loop for efficiency
The split function can be implemented linearly (easier, proof of concept)
but due to abstraction of functionality may use binary split as well.

\subsection{Insertion}

Description of applying the refinement framework to the insert function

\chapter{Conclusions}

\dots