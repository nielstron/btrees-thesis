% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}

The goal of this thesis is to obtain an implementation of B-Trees in the Isabelle/HOL Framework.
The approach is to first design a functional, abstract implementation.
This implementation is the shown to implement a Set-interface,
correctly implementing retrieval, insertion and deletion operations.
In a last step, an imperative implementation is derived that
refines the functional variant.
Thus the proof of correctness for the imperative implementation
is reduced to a proof of equivalence between the output of the
functional and the imperative implementation.
Desirable properties regarding low runtime and high storage usage
are preserved by the obtained implementation.

\section{The Isabelle Proof Assistant}

The Isabelle/HOL tool is an interactive theorem prover.
The user outlines a proof and tells the system which proof methods to apply to
resolve each step.
% TODO more info

\section{The B-Tree Data Structure}

B-Trees were first proposed by Bayer et al. in \parencite{DBLP:journals/acta/BayerM72},
as a data-structure to efficiently store and retrieve indices stored on storage devices
with slow memory access.
In general, B-Trees are hence a special kind of balanced search-trees.
They are different from binary trees in that the number of subtrees is not constant 2
but is defined by the \textit{order} \texttt{k} of the tree.

\subsection{Definitions}

Every node contains a list of \texttt{keys} or \texttt{separators}, index elements, and \texttt{subtrees},
that refer to further B-Trees.
The length of this list is bounded by \texttt{k}.
The separators and subtrees are considered interleaved within a node,
such that we can speak of a "subtree left of a separator" and a "subtree right of a separator",
where for a separator at index \texttt{i} we mean the subtree in the respective
subtree list at index \texttt{i} and \texttt{i+1} respectively.
Note that this already implies that the list of subtrees is one
longer than the list of separators - we refer to the last subtree as the \textit{last} or
\textit{dangling} subtree.
In \parencite{DBLP:journals/acta/BayerM72},
a B-Tree with above structure must fulfill the three properties
\textit{balancedness}, \textit{order} and \textit{sortedness}.

\textit{Balancedness} requires that "each path from the root to any leaf has the same length \texttt{h}",
in other words that the height of all trees in one level of the tree must be equal.

Further the indices must be \textit{sorted} within the tree which means that all indices stored
in the subtree left of a separator are smaller than the value of the separator
and all indices on the right are greater.

In general terms, the property of \textit{order} ensures a certain minimum and maximum
number of subtrees for each node.
However, as pointed out in \parencite{DBLP:books/daglib/0095349_mod},
the property is defined differently in the literature.
For the purpose of this work, the original definition by Bayer et al. was chosen as most suitable.
A B-Tree is of order \textit{k}, if each internal node has at least \textit{k+1}
subtrees and at most \textit{2*k+1}.
The alternative of defining the nodes to have between $\lceil \frac{k}{2} \rceil$
and $k$ children (as proposed in \parencite{DBLP:books/lib/Knuth98a}),
involves cumbersome \textit{real} arithmetic that unnecessarily complicates
mechanized proofs.
Sticking to this definition is further supported by the fact that nodes are supposed
to fill memory pages which are usually of even size (usually some power of 2).
An even number of separators and trees plus one dangling last right tree maximizes
the usage of such a page.

The same ambiguity exists for the term \textit{Leaf} which we will define consistently with Knuth's definition \parencite{DBLP:books/lib/Knuth98a}
to be an empty node, carrying no information.
This is closest to the usual approach in functional programming.
The lowest level of nodes hence contains a list of separators and
list of pointers to leaves.

% TODO insert image of valid B-Tree

\subsection{Desirable Properties}

Due to the potentially large branching factor, combined with the balancing,
the amount of required memory accesses when accessing data is reduced drastically.
This is due to the fact that the overall number of memory accesses is bounded by the depth
of the tree, which again is logarithmic in the number of indices -
where the base of the logarithm is closely proportional to the order \textit{k} of the tree.

Further, the storage usage of B-Trees is at a minimum of $50\%$ at all times,
where the average usage is usually higher. \parencite{DBLP:journals/acta/BayerM72}
This is due to the fact that every node reserves the storage of $2*k$ keys and separators
and by definition always contains at least $k$ elements.

These properties are key to the widespread popularity of B-Trees and are
hence preserved in the given implementation.


\subsection{Applications}

B-Trees are used in almost all modern databases for storing key-value pairs.

\chapter{Functional B-Trees in Isabelle}

Functional specifications of data structures tend to have properties that
are easier to prove than for corresponding imperative implementations
mostly due to the fact that many details of implementation can be abstracted away.
The work therefore begins with a functional specification of B-Trees.

\section{Basic Definitions}
%Definition used for this implementation.
%(esp. order)
%note that k refers to keys+subtrees rather than only keys/subtrees (false! we have k pairs)
%Note equivalence for sortedness properties

Inspired by the design in \parencite{DBLP:conf/popl/MalechaMSW10}, the B-Tree data-structure is defined as follows:

\begin{lstlisting}[mathescape=true, language=Isabelle]
    datatype 'a btree = Leaf | Node "( 'a btree * 'a ) list" "'a btree"
\end{lstlisting}

By interleaving the subtrees and separators, expression of invariants
on the tree is possible without the explicit use of indices into lists.
Since the list of trees is exactly one longer than the list of keys,
the last tree is added to the node in a special position.
The construction leads to the fact that it is easiest to relate any separator
to the subtree on the left, as this subtree is in the same tuple.
Operations that require the subtree on the right can always be expressed as a special
operation on the last tree.

We define the sortedness of a B-Tree based on the \textit{inorder} of the tree,
the concatenation of all elements of the tree in in-order traversal.
Since the tree does no longer have a constant maximum number of elements (as opposed to
e.g. 2-3-4-Trees in \parencite{DBLP:conf/itp/Nipkow16}),
a folding operation is employed to express the resulting string. 

\begin{lstlisting}[mathescape=true, language=Isabelle]
    fun inorder :: "'a btree $\Rightarrow$ 'a list" where
    "inorder Leaf = []" |
    "inorder (Node ts t) = (foldr (@) (map ($\lambda$ (sub, sep). inorder sub @ [sep]) ts) []) @ inorder t"
\end{lstlisting}

That way we can express sortedness of the tree as a simple \texttt{sorted\_less (inorder t)}.

\section{Properties}

Height etc.


\section{Set operations}
% Description of the implementation of the set interface.

With the definition of B-Trees come a number of operations that allow for set-like operations
on the trees - retrieval, insertion and deletion.
Naturally these operations are defined recursively on the nodes of the tree.
Since each node contains a non-trivial number of elements,
a function to navigate to the correct subtree is central to all operations.
We call this function \textit{split}-function,
determining the position in the list of separators and subtrees at which
either the separator is equal to the desired value or the range of the left subtree
contains the desired value.
This approach is similar to the one found in the work of Malecha and Fielding \parencite{DBLP:conf/popl/MalechaMSW10,Fielding80}.\footnote{
    In Fieldings approach the corresponding function is called \textit{index}.
    Malecha calls it \textit{findSubtree}.
}
Usually however, it is integrated into the set-operation
by a linear search that is promised to be replaced by a more efficient binary search
in the actual implementation \parencite{DBLP:books/daglib/0023376,DBLP:journals/acta/BayerM72}
or left in the final code \parencite{DBLP:journals/sosym/ErnstSR15}



\chapter{Imperative B-Trees in Isabelle}

\section{The Imperative Refinement Framework}

Short Description of Peters Refinement framework regarding our implementation

\section{Important low-level data structures}

Note the existence of arrays and blit.
Note further the introduction of partially filled arrays
and the introduction of sblit.

\section{Set-Operations}

\subsection{The split function}

Note the choice of a while-loop for efficiency
The split function can be implemented linearly (easier, proof of concept)
but due to abstraction of functionality may use binary split as well.

\subsection{Insertion}

Description of applying the refinement framework to the insert function

\chapter{Conclusions}

\dots