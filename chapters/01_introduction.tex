% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}

The goal of this thesis is to obtain an implementation of B-Trees in the Isabelle/HOL Framework.
The approach is to first design a functional, abstract implementation.
This implementation is the shown to implement a Set-interface,
correctly implementing retrieval, insertion and deletion operations.
In a last step, an imperative implementation is derived that
refines the functional variant.
Thus the proof of correctness for the imperative implementation
is reduced to a proof of equivalence between the output of the
functional and the imperative implementation.
Desirable properties regarding low runtime and high storage usage
are preserved by the obtained implementation.

\section{The Isabelle Proof Assistant}

The Isabelle/HOL tool is an interactive theorem prover.
The user outlines a proof and tells the system which proof methods to apply to
resolve each step.
% TODO more info

% function notation (like haskell/OCaml)
% proof styles, methods
% locales

\section{The B-Tree Data Structure}

B-Trees were first proposed by Bayer et al. in \parencite{DBLP:journals/acta/BayerM72},
as a data-structure to efficiently store and retrieve indices stored on storage devices
with slow memory access.
In general, B-Trees are hence a special kind of balanced search-trees.
They are different from binary trees in that the number of subtrees is not constant 2
but is defined by the \textit{order} \texttt{k} of the tree.

\subsection{Definitions}
\label{sec:data_structure_defs}

Every node contains a list of \texttt{keys} or \texttt{separators}, index elements, and \texttt{subtrees},
that refer to further B-Trees.
The length of this list is bounded by \texttt{k}.
The separators and subtrees are considered interleaved within a node,
such that we can speak of a subtree left of a separator and a subtree right of a separator,
where for a separator at index \texttt{i} we mean the subtree in the respective
subtree list at index \texttt{i} and \texttt{i+1} respectively.
Note that this already implies that the list of subtrees is one
longer than the list of separators - we refer to the last subtree as the \textit{last} or
\textit{dangling} subtree.
In \parencite{DBLP:journals/acta/BayerM72},
a B-Tree with above structure must fulfill the three properties
\textit{balancedness}, \textit{order} and \textit{sortedness}.

\textit{Balancedness} requires that each path from the root to any leaf has the same length \texttt{h},
in other words that the height of all trees in one level of the tree must be equal.

Further the indices must be \textit{sorted} within the tree which means that all indices stored
in the subtree left of a separator are smaller than the value of the separator
and all indices on the right are greater.

In general terms, the property of \textit{order} ensures a certain minimum and maximum
number of subtrees for each node.
However, as pointed out in \parencite{DBLP:books/daglib/0095349_mod},
the property is defined differently in the literature.
For the purpose of this work, the original definition by Bayer et al. was chosen as most suitable.
A B-Tree is of order \textit{k}, if each internal node has at least \textit{k+1}
subtrees and at most \textit{2*k+1}.
The alternative of defining the nodes to have between $\lceil \frac{k}{2} \rceil$
and $k$ children (as proposed in \parencite{DBLP:books/lib/Knuth98a}),
involves cumbersome \textit{real} arithmetic that unnecessarily complicates
mechanized proofs.
Sticking to this definition is further supported by the fact that nodes are supposed
to fill memory pages which are usually of even size (usually some power of 2).
An even number of separators and trees plus one dangling last right tree maximizes
the usage of such a page.

The same ambiguity exists for the term \textit{Leaf} which we will define consistently with Knuth's definition \parencite{DBLP:books/lib/Knuth98a}
to be an empty node, carrying no information.
This is closest to the usual approach in functional programming.
The lowest level of nodes hence contains a list of separators and
list of pointers to leaves.

% TODO insert image of valid B-Tree

\subsection{Desirable Properties}

Due to the potentially large branching factor, combined with the balancing,
the amount of required memory accesses when accessing data is reduced drastically.
This is due to the fact that the overall number of memory accesses is bounded by the depth
of the tree, which again is logarithmic in the number of indices -
where the base of the logarithm is closely proportional to the order \textit{k} of the tree.

Further, the storage usage of B-Trees is at a minimum of $50\%$ at all times,
where the average usage is usually higher. \parencite{DBLP:journals/acta/BayerM72}
This is due to the fact that every node reserves the storage of $2*k$ keys and separators
and by definition always contains at least $k$ elements.

These properties are key to the widespread popularity of B-Trees and are
hence preserved in the given implementation.


\subsection{Applications}

B-Trees are used in almost all modern databases for storing key-value pairs.

\chapter{Functional B-Trees in Isabelle}

Functional specifications of data structures tend to have properties that
are easier to prove than for corresponding imperative implementations
mostly due to the fact that many details of implementation can be abstracted away.
The work therefore begins with a functional specification of B-Trees.

\section{Basic Definitions}
%Definition used for this implementation.
%(esp. order)
%note that k refers to keys+subtrees rather than only keys/subtrees (false! we have k pairs)

% TODO all function equations similar to math equations, setting variables in italics

Inspired by the design in \parencite{DBLP:conf/popl/MalechaMSW10}, the B-Tree data-structure is defined as follows:

\begin{lstlisting}[mathescape=true, language=Isabelle]
datatype 'a btree = Leaf | Node ( 'a btree * 'a ) list 'a btree
\end{lstlisting}

By interleaving the subtrees and separators, expression of invariants
on the tree is possible without the explicit use of indices into lists.
Since the list of trees is exactly one longer than the list of keys,
the last tree is added to the node in a special position.
The construction leads to the fact that it is easiest to relate any separator
to the subtree on the left, as this subtree is in the same tuple.
Operations that require the subtree on the right can always be expressed as a special
operation on the last tree.

The balancedness of a B-Tree is defined in a straightforward fashion, making use
of an intuitively defined height\footnote{
    Note that the actual implementation of height is slightly different,
    however this is of no importance in any proofs but rather notationally convenient.
}.
There is a choice here, namely whether to fix the balancedness of a tree
on some arbitrary number or on a known value.
Since we know the last tree in the node exists and further
know that all in the node have the same height as that tree,
we simply choose the height of the last tree as an anchor point.

\begin{lstlisting}[mathescape=true, language=Isabelle]

fun height :: 'a btree $\Rightarrow$ nat where
  height Leaf = 0 |
  height (Node ts t) = Suc (fold max (map height (subtrees ts)) (height t))

fun bal :: 'a btree $\Rightarrow$ bool where
    bal Leaf = True |
    bal (Node ts t) = (
      ($\forall$sub $\in$ set (subtrees ts). height t = height sub) $\wedge$
      ($\forall$sub $\in$ set (subtrees ts). bal sub) $\wedge$
      bal t
    )
\end{lstlisting}

Further the \textit{order} of the trees needs to be formally defined.
As discussed in \autoref{sec:data_structure_defs}, the most useful choice here is
to allow for at least $k$ and at most $2*k+1$ subtrees.
Since the last subtree is fixed, this means that the length of list of keys and children
itself has to be between $k$ and $2*k$.
Note that we also need a special property for the root of the tree,
which has between one and $2*k$ elements.
In mathematical equations, we will denote "order $k$ $t$" as "$\order_k t$"
for convenience (likewise for "root\_order $k$ $t$"), which is to be read as
"Tree $t$ is of order $k$".

\begin{lstlisting}[mathescape=true, language=Isabelle]

fun order :: nat $\Rightarrow$ 'a btree $\Rightarrow$ bool where
    order k Leaf = True |
    order k (Node ts t) = (
    (length ts $\ge$ k)  $\wedge$
    (length ts $\le$ 2*k) $\wedge$
    ($\forall$sub $\in$ set (subtrees ts). order k sub) $\wedge$
    order k t
  )

fun root_order where
  root_order k Leaf = True |
  root_order k (Node ts t) = (
  (length ts $>$ 0) $\wedge$
  (length ts $\le$ 2*k) $\wedge$
  ($\forall$s $\in$ set (subtrees ts). order k s) $\wedge$
   order k t
)

\end{lstlisting}

We define the sortedness of a B-Tree based on the \textit{inorder} of the tree,
which is the concatenation of all elements of the tree in in-order traversal.
Since the tree does no longer have a constant maximum number of elements (as opposed to
e.g. 2-3-4-Trees in \parencite{DBLP:conf/itp/Nipkow16}),
a concatenation function for lists of strings
is employed to express the resulting string.
Note that this definition reads a bit inconveniently
as the list of subtrees and separators is first mapped and then concatenated.
However since we make recursive use of the inorder-function
inside the mapping expression, we can only later on cover up this expression
by using abbreviations.

\begin{lstlisting}[mathescape=true, language=Isabelle]
fun inorder :: 'a btree $\Rightarrow$ 'a list where
    inorder Leaf = [] |
    inorder (Node ts t) = (concat (map ($\lambda$ (sub, sep). inorder sub @ [sep]) ts)) @ inorder t

abbreviation inorder_pair  $\equiv$ $\lambda$(sub,sep). inorder sub @ [sep]
abbreviation inorder_list ts $\equiv$ concat (map inorder_pair ts)
\end{lstlisting}

That way we can express sortedness of the tree $t$ as a simple "sorted\_less (inorder $t$)".
This definition is very compact and brings for another benefit pointed out by Nipkow et al in \parencite{DBLP:conf/itp/Nipkow16}.
Many properties of B-Trees follow intuitively by considering
the inorder view on the tree as it is invariant for many operations (i.e. stealing from the right neighbor node).
We will see later how the use of this fact comes in handy for proving
important properties of the implementation.
 % TODO note benefit over btree_sorted

\section{Properties}

%Height etc.
As pointed out by Bayer in the first paper describing B-Trees,
the height of B-Trees is logarithmic with respect to the number
of nodes of the tree. \parencite{DBLP:journals/acta/BayerM72}
The paper even gives a precise lower and upper bound, which will be quickly sketched in the following.

First, we define the number of nodes in a tree:
\begin{lstlisting}[mathescape=true, language=Isabelle]
fun nodes :: 'a btree $\Rightarrow$ nat where
    nodes Leaf = 0 |
    nodes (Node ts t) = 1 + ($\sum$t$\leftarrow$subtrees ts. nodes t) + (nodes t)
\end{lstlisting}

%To work with this equation, we just need to add one auxiliary lemmas to the standard canon
%\begin{lemma}
%\begin{lstlisting}[mathescape=true, language=Isabelle]
%    sum_list (replicate n c) = n*c
%\end{lstlisting}
%\end{lemma}

By induction on the computation of the nodes function we obtain bounds
on the number of nodes of an subtree with respect to its height
(note that "order" is assumed rather than "root\_order").

\begin{lemma}
    \label{lem:bound_internal_node}
    $\order_k t \wedge \bal t \longrightarrow$
    \begin{align}
        (k+1)^{\height t} - 1 &\le \nodes t * k \\
        \nodes t * 2k &\le (2k+1)^{\height t} - 1
    \end{align}
\end{lemma}

From \autoref{lem:bound_internal_node} we can almost directly obtain
the bounds on valid roots of B-Trees.

\begin{theorem}
    $\rootorder_k t \wedge \bal t \wedge k > 0 \longrightarrow$
    \begin{equation}
        2((k+1)^{\height t - 1} - 1) \div k + (t \neq Leaf) \le \nodes t \le ((2k+1)^{\height t} - 1) \div 2k
    \end{equation}
\end{theorem}

These bounds are sharp, which can be proven by first showing that
the bounds for internal nodes are sharp.
We define functions that generate exactly those trees
that satisfy the requirements of B-Trees, have a given height
and satisfy the inequality with equality.

\begin{lstlisting}[mathescape=true, language=Isabelle]

fun full_node where
  full_node k c 0 = Leaf |
  full_node k c (Suc n) = (Node (replicate (2*k) ((full_node k c n),c)) (full_node k c n))

fun slim_node where
  slim_node k c 0 = Leaf |
  slim_node k c (Suc n) = (Node (replicate k ((slim_node k c n),c)) (slim_node k c n))

definition full_tree = full_node

fun slim_tree where
  slim_tree k c 0 = Leaf |
  slim_tree k c (Suc h) = Node [(slim_node k c h, c)] (slim_node k c h)

\end{lstlisting}

\begin{lemma} $t := \fullnode k\ a\ h \wedge t' := \slimnode k\ a\ h \longrightarrow h = \height t \wedge$
    \begin{align}
    ((2k+1)^h - 1) &= \nodes t * (2k) &\wedge \order_k t \wedge \bal t \\ 
    ((k+1)^h - 1) &= \nodes t * k  &\wedge \order_k t \wedge \bal t
    \end{align}
\end{lemma}

\begin{theorem}
    $k > 0 \wedge t := \fulltree k\ a\ h \wedge t' := \slimtree k\ a\ h \longrightarrow h = \height t \wedge$
    \begin{align}
        ((2k+1)^h - 1) &= \nodes t * (2k) &\wedge \rootorder_k t \wedge \bal t \\ 
        2((k+1)^h - 1) + k(t \neq Leaf) &= \nodes t * k  &\wedge \rootorder_k t \wedge \bal t
    \end{align}
\end{theorem}


\section{Set operations}
% Description of the implementation of the set interface.
% TODO note that the proof for  sortedness has been reduced from 2000 lines
% by the sorted (inorder ...) notation (and Nipkows auxiliary funs/lemmas)

With the definition of B-Trees come a number of operations that allow for set-like operations
on the trees - retrieval, insertion and deletion.
Naturally these operations are defined recursively on the nodes of the tree.
Since each node contains a non-trivial number of elements,
a function to navigate to the correct subtree is central to all operations.
We call this function \textit{split}-function,
determining the position in the list of separators and subtrees at which
either the separator is equal to the desired value or the range of the left subtree
contains the desired value.
This approach is similar to the one found in the work of Malecha and Fielding \parencite{DBLP:conf/popl/MalechaMSW10,Fielding80}.\footnote{
    In Fieldings approach the corresponding function is called \textit{index}.
    Malecha calls it \textit{findSubtree}.
}
Usually however, it is integrated into the set-operation
by a linear search that is promised to be replaced by a more efficient binary search
in the actual implementation \parencite{DBLP:books/daglib/0023376,DBLP:journals/acta/BayerM72}
or left in the final code \parencite{DBLP:journals/sosym/ErnstSR15}

For this work, I have started out by defining a simple split function
that walks through the subtree-separator list linearly and returns
a tupel that ....

then abtract from that ...

prove everything based on abstract definition -> locale % TODO add to isabelle intro


\chapter{Imperative B-Trees in Isabelle}

\section{The Imperative Refinement Framework}

Short Description of Peters Refinement framework regarding our implementation

\section{Important low-level data structures}

Note the existence of arrays and blit.
Note further the introduction of partially filled arrays
and the introduction of sblit.

\section{Set-Operations}

\subsection{The split function}

Note the choice of a while-loop for efficiency
The split function can be implemented linearly (easier, proof of concept)
but due to abstraction of functionality may use binary split as well.

\subsection{Insertion}

Description of applying the refinement framework to the insert function

\chapter{Conclusions}

\dots